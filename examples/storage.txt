### Set up interrupt vectors
loadwi 15 0

# first vector
strapr 15 .intr_vec

# Point to next vector
addi 15 1 15

# Remaining vectors
.write_vector
strapr 15 .exit
addi 15 1 15
jmpgei 15 FF .write_done  # 256 vectors
jmp .write_vector  # Next vector

.write_done

# Enable interrupts
loadwi 25 00000001

### Set up interrupt controller
savewi 40 FFFFEFD2
savewi .keyboard_intr FFFFEFD6
savebi 1 FFFFEFDA
savewi 0 FFFFEFCE

### Set up keyboard
savewi 1 FFFFEFC1

### Write enable the storage device
savewi 1 FFFFEDB4

### Store the size of the storage device in E
loadw E FFFFEDB8

### Main loop
.loop

# Wait for interrupt
wait

# Check flag
jmpeqi A 1 .exit

# Write to disk at offset C (modulo 512)
addi C FFFFEDBC D
savebr B D

# Compute next offset
addi C 1 C

# Are we over the window?
jmplti C 200 .lt_200

# Reset and shift the offset to the next 512-byte block
loadwi C 0
loadw D FFFFEDB0
addi D 200 D

# Did we overshoot?
jmple D E .save_offset

# We overshot the size, wrap around
loadwi D 0

# Save the new offset to the storage offset register
.save_offset
savew D FFFFEDB0

.lt_200

# And back around
jmp .loop


### Keyboard interrupt
.keyboard_intr

# Read keystroke
loadw B FFFFEFC5

# Print it if nonzero
jmpeqi B 0 .return
saveb B FFFFEFFF

# Is the keystroke a tilde?
jmpnei B 7E .return

# It is, so set the flag to exit
loadwi A 1

# Return
.return
# Reenable interrupts
savewi 0 FFFFEFCE 0
rfe

### End program
.exit
halt

### Interrupt vector
.intr_vec
jmp FFFFEFEA
